%{
    #include "parser.hpp"
    #include "output.hpp"

    #include <iostream>
    using namespace std;
    int yylex();
    void yyerror(char const*);
%}

%token VOID INT BYTE B BOOL AND OR NOT TRUE FALSE RETURN IF ELSE WHILE BREAK CONTINUE SC COMMA LPAREN RPAREN LBRACE
%token RBRACE ASSIGN RELOP BINOP ID NUM STRING epsilon

%%

Program :
    Funcs                           {output::printProductionRule(0);}
;

Funcs :
    epsilon                         {output::printProductionRule(1);}
    |   FuncDecl Funcs              {output::printProductionRule(2);}

FuncDecl:
    RetType ID LPAREN RPAREN Formals LBRACE Statements RBRACE {output::printProductionRule(3);}
;

RetType:
    Type                            {output::printProductionRule(4);}
    |   VOID                        {output::printProductionRule(5);}

Formals:
    epsilon                         {output::printProductionRule(6);}
    | FormalsList                   {output::printProductionRule(7);}

FormalsList:
    FormalDecl                      {output::printProductionRule(8);}
    | FormalDecl COMMA FormalsList  {output::printProductionRule(9);}

FormalDecl:
    Type ID                         {output::printProductionRule(10);}

Statements:
    Statement                       {output::printProductionRule(10);}
    | Statement Statement           {output::printProductionRule(12);}
    | LBRACE Statement RBRACE       {output::printProductionRule(13);}

Statement:
    Type ID SC                      {output::printProductionRule(14);}
    | Type ID ASSIGN Exp SC         {output::printProductionRule(15);}
    | ID ASSIGN Exp SC              {output::printProductionRule(16);}
    | Call SC                       {output::printProductionRule(17);}
    | RETURN SC                     {output::printProductionRule(18);}
    | RETURN Exp SC                 {output::printProductionRule(19);}
    | IF LPAREN Exp RPAREN Statement                           {output::printProductionRule(20);}
    | IF LPAREN Exp RPAREN Statement ELSE Statement            {output::printProductionRule(21);}
    | WHILE LPAREN Exp RPAREN Statement                        {output::printProductionRule(22);}
    | WHILE LPAREN Exp RPAREN Statement ELSE Statement         {output::printProductionRule(23);}
    | BREAK SC                      {output::printProductionRule(24);}
    | CONTINUE SC                   {output::printProductionRule(25);}

Call:
    ID LPAREN ExpList RPAREN        {output::printProductionRule(26);}
    |   ID LPAREN RPAREN            {output::printProductionRule(27);}

ExpList:
    Exp                             {output::printProductionRule(28);}
    | Exp COMMA ExpList             {output::printProductionRule(29);}

Type:
    INT                             {output::printProductionRule(30);}
    |   BYTE                        {output::printProductionRule(31);}
    |   BOOL                        {output::printProductionRule(32);}
Exp:
    LPAREN Exp RPAREN               {output::printProductionRule(33);}
    | Exp BINOP Exp                 {output::printProductionRule(34);}
    | ID                            {output::printProductionRule(35);}
    | Call                          {output::printProductionRule(36);}
    | NUM                           {output::printProductionRule(37);}
    | NUM B                         {output::printProductionRule(38);}
    | STRING                        {output::printProductionRule(39);}
    | TRUE                          {output::printProductionRule(40);}
    | FALSE                         {output::printProductionRule(41);}
    | NOT Exp                       {output::printProductionRule(42);}
    | Exp AND Exp                   {output::printProductionRule(43);}
    | Exp OR Exp                    {output::printProductionRule(44);}
    | Exp RELOP Exp                 {output::printProductionRule(45);}

%%

int main()
{
    return yyparse();
}

void yyerror(char const* s){
    printf("Parse Error: %s\n",s);
    exit(1);
}